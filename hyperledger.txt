chapter 3
#hyperledger fabric architecture and components

##hyperledger fabric overview

*

##hyperledger fabric model

*follows the _execute-order-validate_ paradigm:

..*fabric ckecks the transactions correctness, produces state updates for the transaction. _endorsers_: nodes executing transactions. they are called to validate and add a set of state updates produced as the result of a computation. multiple transactions can be executed simultaneously. state updates may contain conflicts.

..*fabric ordering service follows the consensus protocol. _orderers_:nodes running the consensus algorithm.

..*fabric validates the transaction to ensure that: a)transactions are executed according to the given trans. logic. b)no state conflicts exist among transactions wanting to update the same state. after transactions are validated, tey are added to the ledger using commiter nodes, endorsers.

*benefits of _execute-order-validate_:
..*nodes ordering transactions are also executing them, validating the order and computations.
..*it enables the parallel execution of multiple transactions by different parts of the network.

*fabric has six capabilities:
..*identity management: the membership service provider (_msp_) handles identity management. it manages user ids and authenticates all participants on the network.
..*privacy and confidentiality: _private channels_ are restricted message routes used for trans. between subsets of network members. channels deliver promises only with trusted ordering services. _private data collections_ (_pdc_) are offerec when the ordering service cannot be trusted and can be considered a partition of a ledger visible only to a subset network.
..*efficient processing:  
are offerec when the ordering service cannot be trusted and can be considered a partition of a ledger visible only to a subset network.
..*efficient processing:are offerec when the ordering service cannot be trusted and can be considered a partition of a ledger visible only to a subset network.
..*efficient processing:
..*business login: the smart contract or _chaincode_ defines the business logic that constitutes the execution of a transaction.
..*governance: _policies_ express governance models, and it is required to identify the parties that can deploy a chaincode or add an msp to a channel. 
..*modular architecture: 

##blockchain network
*

##identity
*each component that is part of the network, nodes, computers, administrators, clients, have certified credentials generated by one or more authorities.
*these credentials accredit them as network operators.
*once an identity is issued it will act on the network according to its assigned policies.
*the job of policies is to set authentication parameters such as who has access to what and what actions an identity holder can perform in the network.
*fabric does not ipose any identity technology, nevertheless fabric can support any _public-key infrastructure (_PKI_).
*a pki manages digital identities.
*a digitial identity is bount to a pair of keys public and private.
*identities can be revoked, losig the ability to operate in the network.

##membership service provider (msp)
*it provides a generic notion of id and the rules to assert its validity, also an api for authentication.
*fabric uses one or more msps to manage identities and their life cycles in its network.
*msp does not prescribe how identities should be issued only how they should be validated.
*fabric becomes permissionless as soon as a given network is equipped with an msp that accepts any public keys.

##policies
*they configure who can do what and on which element of the network.
*they set the governance of the network.
*they govern who is allowed to access a given ledger, who can deploy a chaincode, who can upgrade the channel configuration.
*_system channel_: the first plase wher policies are encountered. it contains the msps that identify the farties that form the ordering service (ordering organizations), and msps identifying the identities that can transact in the network (_consortium organizations_). using thos msps the system channel identifies who can create application channels, via a policy included in the system channels genesis block.
*a channel genesis block is the second place wher policies appear. creating a new channel sets policies to add and remove members and to approve a chaincode before ir is defined and commited to the channel. if policies are not set they are inherited from the sstem channel.
*policies are the tools that admins use to govern a fabric network. they can be set to configure a network to be permissionless or can be set to restrict access to specific processes.

##nodes
*nodes are the communication entities of the blockchain.
*a node has an identity that allows to perform certain operations:
..*clients:initiate the life cycle of a transaction in fabric.
..*endorsers:responsible for the execution of business logic, chaincodes.
..*orderers: participate in the consensus algoritm, decide the order of transactions.
##nodes
*nodes are the communication entities of the blockchain.
*a node has an identity that allows to perform certain operations:
..*clients:initiate the life cycle of a transaction in fabric.
..*endorsers:responsible for the execution of business logic, chaincodes.
..*orderers: participate in the consensus algoritm, decide the order of transactions.
..*committers: fetch the ledger from orderers and apply validation logic to establish the validity of each ordered transaction. endorseres are also committers.

##chaincode
*smart contract is known as chaincode.
*it is a pice of code that implements the application logic and runs during the execution phase.
*it is not required to be deterministic.
*a chaincode mus expose two functions: init and invoke.
*init is used to initialize any data structure at initialization time.
*invoke recieves arguments, on these the chaincode decides what to operation
*a chaincode can be thought of as a namespace insidde th ledger that groups a set of key-value pairs managed by that chaincode.
*steps required to successfully commit a transaction:
..*propose the transaction: a client prepares and sends a transaction proposal to the endorsers of the chaincode the proposal is targeting. this proposal specifies the chaincode and the arguments for the chaincode invocation.
..*execute the transaction proposal. the endorsers execute, _simulate_, the chaincode with the raguments provided in the proposal (invoke). the result consists of a return value and a _read write_ set. The read write set is a data structure that captures the updates to the dependencies on the world state. the execution of the chaincode is called simulation because the world state does not change at this stage, these are proposed changes that need to be validated. all peers that execute the chaincode sign the output of the execution and send it back to the application. this signature is called an _endorsement_.
..*
